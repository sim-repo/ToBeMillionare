//
//  AvaKit.swift
//  ProjectName
//
//  Created by Igor Ivanov on 30.08.2020.
//  Copyright Â© 2020 None. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class AvaKit : NSObject {

    //// Drawing Methods

    @objc dynamic public class func drawMiniAva(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 54, height: 54), resizing: ResizingBehavior = .aspectFit, showStageScore: CGFloat = 0.153) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 54, height: 54), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 54, y: resizedFrame.height / 54)


        //// Color Declarations
        let color2 = UIColor(red: 0.071, green: 0.086, blue: 1.000, alpha: 1.000)
        let color3 = UIColor(red: 0.192, green: 1.000, blue: 0.953, alpha: 1.000)
        let color4 = UIColor(red: 0.980, green: 0.000, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let gradient1 = CGGradient(colorsSpace: nil, colors: [color2.cgColor, color3.cgColor, color2.cgColor] as CFArray, locations: [0, 0.5, 1])!

        //// Variable Declarations
        let sageScoreExp: CGFloat = 360 * showStageScore

        //// Group 138
        //// Oval 13 Drawing
        let oval13Path = UIBezierPath(ovalIn: CGRect(x: 0, y: 0, width: 54, height: 54))
        context.saveGState()
        oval13Path.addClip()
        context.drawLinearGradient(gradient1, start: CGPoint(x: 46.09, y: 7.91), end: CGPoint(x: 7.91, y: 46.09), options: [])
        context.restoreGState()


        //// Oval 15 Drawing
        let oval15Rect = CGRect(x: 0, y: 0, width: 54, height: 54)
        let oval15Path = UIBezierPath()
        oval15Path.addArc(withCenter: CGPoint(x: oval15Rect.midX, y: oval15Rect.midY), radius: oval15Rect.width / 2, startAngle: -sageScoreExp * CGFloat.pi/180, endAngle: 0 * CGFloat.pi/180, clockwise: true)
        oval15Path.addLine(to: CGPoint(x: oval15Rect.midX, y: oval15Rect.midY))
        oval15Path.close()

        color4.setFill()
        oval15Path.fill()


        //// Bkg 2 Drawing
        let bkg2Path = UIBezierPath(ovalIn: CGRect(x: 3, y: 3, width: 48, height: 48))
        UIColor.black.setFill()
        bkg2Path.fill()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawAva(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 236, height: 212), resizing: ResizingBehavior = .aspectFit, showAva: CGFloat = 0.31, showDetails: CGFloat = 0.504, showStageScore: CGFloat = 0.153, showBankScore: CGFloat = 0.082, showDetailBlink: CGFloat = 0, showBlink: CGFloat = 0, depoText: String = "$1000", stageText: String = "2") {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 236, height: 212), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 236, y: resizedFrame.height / 212)


        //// Color Declarations
        let color2 = UIColor(red: 0.071, green: 0.086, blue: 1.000, alpha: 1.000)
        let color3 = UIColor(red: 0.192, green: 1.000, blue: 0.953, alpha: 1.000)
        let color4 = UIColor(red: 0.980, green: 0.000, blue: 1.000, alpha: 1.000)
        let gradientColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 0.000)
        let gradientColor2 = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 0.000)
        let gradientColor3 = UIColor(red: 0.000, green: 0.138, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let gradient1 = CGGradient(colorsSpace: nil, colors: [color2.cgColor, color3.cgColor, color2.cgColor] as CFArray, locations: [0, 0.5, 1])!
        let gradient = CGGradient(colorsSpace: nil, colors: [gradientColor2.cgColor, gradientColor2.blended(withFraction: 0.5, of: gradientColor3).cgColor, gradientColor3.cgColor, gradientColor3.blended(withFraction: 0.5, of: gradientColor).cgColor, gradientColor.cgColor] as CFArray, locations: [0.5, 0.51, 0.51, 0.51, 0.52])!
        let gradient2 = CGGradient(colorsSpace: nil, colors: [UIColor.black.cgColor, UIColor.white.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let showAvaExp: CGFloat = showAva <= 0.2 ? showAva * 5 : (showAva <= 0.3 ? abs(cos((1 - showAva) * 1.25 * CGFloat.pi * 10 / CGFloat.pi * 180 * CGFloat.pi/180)) * 0.4 + 0.6 : (showAva >= 0.5 && showAva <= 1 ? abs(sin((showAva - 0.5) * 2 * CGFloat.pi/180)) / CGFloat.pi * 180 : 1))
        let showDetailsExp: CGFloat = showDetails <= 0.2 ? showDetails * 5 : (showDetails <= 0.3 ? abs(cos((1 - showDetails) * 1.25 * CGFloat.pi * 10 / CGFloat.pi * 180 * CGFloat.pi/180)) * 0.4 + 0.6 : (showDetails >= 0.5 && showDetails <= 1 ? abs(sin((showDetails - 0.5) * 2 * CGFloat.pi/180)) / CGFloat.pi * 180 : 1))
        let sageScoreExp: CGFloat = 360 * showStageScore
        let showBankScoreExp: CGFloat = 360 * showBankScore
        let showDetailBlinkExp: CGFloat = -86 * showDetailBlink
        let showBlinkExp: CGFloat = -180 * (1 - showBlink)

        //// Group 141
        //// Oval 2 Drawing
        context.saveGState()
        context.translateBy(x: 156, y: 80)
        context.scaleBy(x: showAvaExp, y: showAvaExp)

        let oval2Path = UIBezierPath(ovalIn: CGRect(x: -80, y: -80, width: 160, height: 160))
        context.saveGState()
        oval2Path.addClip()
        context.drawLinearGradient(gradient1, start: CGPoint(x: 56.57, y: -56.57), end: CGPoint(x: -56.57, y: 56.57), options: [])
        context.restoreGState()

        context.restoreGState()


        //// BlinkGroup 3
        context.saveGState()
        context.beginTransparencyLayer(auxiliaryInfo: nil)


        //// Oval 5 Drawing
        let oval5Path = UIBezierPath(ovalIn: CGRect(x: 76, y: 0, width: 160, height: 160))
        context.saveGState()
        oval5Path.addClip()
        context.drawLinearGradient(gradient1, start: CGPoint(x: 156, y: 0), end: CGPoint(x: 156, y: 160), options: [])
        context.restoreGState()


        //// Rectangle 3 Drawing
        context.saveGState()
        context.translateBy(x: 76, y: 0)

        context.saveGState()
        context.setBlendMode(.sourceIn)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        let rectangle3Rect = CGRect(x: 0, y: showBlinkExp, width: 181.12, height: 340)
        let rectangle3Path = UIBezierPath(rect: rectangle3Rect)
        context.saveGState()
        rectangle3Path.addClip()
        context.drawLinearGradient(gradient,
            start: CGPoint(x: rectangle3Rect.midX, y: rectangle3Rect.minY),
            end: CGPoint(x: rectangle3Rect.midX, y: rectangle3Rect.maxY),
            options: [])
        context.restoreGState()

        context.endTransparencyLayer()
        context.restoreGState()

        context.restoreGState()


        context.endTransparencyLayer()
        context.restoreGState()


        //// Oval Drawing
        context.saveGState()
        context.translateBy(x: 156, y: 80)
        context.scaleBy(x: showAvaExp, y: showAvaExp)

        let ovalPath = UIBezierPath(ovalIn: CGRect(x: -70, y: -70, width: 140, height: 140))
        UIColor.black.setFill()
        ovalPath.fill()

        context.restoreGState()


        //// Stage
        context.saveGState()
        context.translateBy(x: 123.31, y: 131.63)
        context.scaleBy(x: showDetailsExp, y: showDetailsExp)



        //// Oval 26 Drawing
        let oval26Path = UIBezierPath(ovalIn: CGRect(x: -80, y: 0, width: 80, height: 80))
        context.saveGState()
        oval26Path.addClip()
        context.drawLinearGradient(gradient1, start: CGPoint(x: -40, y: 0), end: CGPoint(x: -40, y: 80), options: [])
        context.restoreGState()


        //// Oval 27 Drawing
        let oval27Rect = CGRect(x: -80, y: 0, width: 80, height: 80)
        let oval27Path = UIBezierPath()
        oval27Path.addArc(withCenter: CGPoint(x: oval27Rect.midX, y: oval27Rect.midY), radius: oval27Rect.width / 2, startAngle: -sageScoreExp * CGFloat.pi/180, endAngle: 0 * CGFloat.pi/180, clockwise: true)
        oval27Path.addLine(to: CGPoint(x: oval27Rect.midX, y: oval27Rect.midY))
        oval27Path.close()

        color4.setFill()
        oval27Path.fill()


        //// Oval 28 Drawing
        let oval28Path = UIBezierPath(ovalIn: CGRect(x: -75, y: 5, width: 70, height: 70))
        UIColor.black.setFill()
        oval28Path.fill()


        //// BlinkGroup 2
        context.saveGState()
        context.beginTransparencyLayer(auxiliaryInfo: nil)


        //// Oval 4 Drawing
        let oval4Path = UIBezierPath(ovalIn: CGRect(x: -75, y: 5, width: 70, height: 70))
        UIColor.black.setFill()
        oval4Path.fill()


        //// Rectangle 2 Drawing
        context.saveGState()
        context.translateBy(x: -2.31, y: 0.37)

        context.saveGState()
        context.setBlendMode(.sourceIn)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        let rectangle2Rect = CGRect(x: showDetailBlinkExp, y: 0, width: 13, height: 80)
        let rectangle2Path = UIBezierPath(rect: rectangle2Rect)
        context.saveGState()
        rectangle2Path.addClip()
        context.drawLinearGradient(gradient2,
            start: CGPoint(x: rectangle2Rect.maxX, y: rectangle2Rect.midY),
            end: CGPoint(x: rectangle2Rect.minX, y: rectangle2Rect.midY),
            options: [])
        context.restoreGState()

        context.endTransparencyLayer()
        context.restoreGState()

        context.restoreGState()


        context.endTransparencyLayer()
        context.restoreGState()


        //// Text 13 Drawing
        let text13Rect = CGRect(x: -63, y: 3, width: 50, height: 32)
        let text13TextContent = "ÑÑ."
        let text13Style = NSMutableParagraphStyle()
        text13Style.alignment = .center
        let text13FontAttributes = [
            .font: UIFont(name: "Play", size: 21)!,
            .foregroundColor: UIColor.white,
            .paragraphStyle: text13Style,
        ] as [NSAttributedString.Key: Any]

        let text13TextHeight: CGFloat = text13TextContent.boundingRect(with: CGSize(width: text13Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text13FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text13Rect)
        text13TextContent.draw(in: CGRect(x: text13Rect.minX, y: text13Rect.minY + (text13Rect.height - text13TextHeight) / 2, width: text13Rect.width, height: text13TextHeight), withAttributes: text13FontAttributes)
        context.restoreGState()


        //// Text 15 Drawing
        let text15Rect = CGRect(x: -60, y: 35, width: 37, height: 29)
        let text15Style = NSMutableParagraphStyle()
        text15Style.alignment = .center
        let text15FontAttributes = [
            .font: UIFont(name: "Play", size: 32)!,
            .foregroundColor: UIColor.white,
            .paragraphStyle: text15Style,
        ] as [NSAttributedString.Key: Any]

        let text15TextHeight: CGFloat = stageText.boundingRect(with: CGSize(width: text15Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text15FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text15Rect)
        stageText.draw(in: CGRect(x: text15Rect.minX, y: text15Rect.minY + (text15Rect.height - text15TextHeight) / 2, width: text15Rect.width, height: text15TextHeight), withAttributes: text15FontAttributes)
        context.restoreGState()



        context.restoreGState()


        //// Bank
        context.saveGState()
        context.translateBy(x: 79.39, y: 75.86)
        context.scaleBy(x: showDetailsExp, y: showDetailsExp)



        //// Oval 29 Drawing
        let oval29Path = UIBezierPath(ovalIn: CGRect(x: -79.08, y: -41.23, width: 80, height: 80))
        context.saveGState()
        oval29Path.addClip()
        context.drawLinearGradient(gradient1, start: CGPoint(x: -39.08, y: -41.23), end: CGPoint(x: -39.08, y: 38.77), options: [])
        context.restoreGState()


        //// Oval 30 Drawing
        let oval30Rect = CGRect(x: -79.08, y: -41.23, width: 80, height: 80)
        let oval30Path = UIBezierPath()
        oval30Path.addArc(withCenter: CGPoint(x: oval30Rect.midX, y: oval30Rect.midY), radius: oval30Rect.width / 2, startAngle: -showBankScoreExp * CGFloat.pi/180, endAngle: 0 * CGFloat.pi/180, clockwise: true)
        oval30Path.addLine(to: CGPoint(x: oval30Rect.midX, y: oval30Rect.midY))
        oval30Path.close()

        color4.setFill()
        oval30Path.fill()


        //// Oval 31 Drawing
        let oval31Path = UIBezierPath(ovalIn: CGRect(x: -74.08, y: -36.23, width: 70, height: 70))
        UIColor.black.setFill()
        oval31Path.fill()


        //// BlinkGroup
        context.saveGState()
        context.beginTransparencyLayer(auxiliaryInfo: nil)


        //// Oval 3 Drawing
        let oval3Path = UIBezierPath(ovalIn: CGRect(x: -74.08, y: -36.23, width: 70, height: 70))
        UIColor.black.setFill()
        oval3Path.fill()


        //// Rectangle Drawing
        context.saveGState()
        context.translateBy(x: -2.39, y: -41.86)

        context.saveGState()
        context.setBlendMode(.sourceIn)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        let rectangleRect = CGRect(x: showDetailBlinkExp, y: 0, width: 13, height: 80)
        let rectanglePath = UIBezierPath(rect: rectangleRect)
        context.saveGState()
        rectanglePath.addClip()
        context.drawLinearGradient(gradient2,
            start: CGPoint(x: rectangleRect.maxX, y: rectangleRect.midY),
            end: CGPoint(x: rectangleRect.minX, y: rectangleRect.midY),
            options: [])
        context.restoreGState()

        context.endTransparencyLayer()
        context.restoreGState()

        context.restoreGState()


        context.endTransparencyLayer()
        context.restoreGState()


        //// Text 16 Drawing
        let text16Rect = CGRect(x: -74.6, y: -18.05, width: 70.04, height: 32)
        let text16Style = NSMutableParagraphStyle()
        text16Style.alignment = .center
        let text16FontAttributes = [
            .font: UIFont(name: "Play", size: 22)!,
            .foregroundColor: UIColor.white,
            .paragraphStyle: text16Style,
        ] as [NSAttributedString.Key: Any]

        let text16TextHeight: CGFloat = depoText.boundingRect(with: CGSize(width: text16Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text16FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text16Rect)
        depoText.draw(in: CGRect(x: text16Rect.minX, y: text16Rect.minY + (text16Rect.height - text16TextHeight) / 2, width: text16Rect.width, height: text16TextHeight), withAttributes: text16FontAttributes)
        context.restoreGState()



        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawAvaImage(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 164, height: 200), resizing: ResizingBehavior = .aspectFit, userName: String = "Ð½Ð¾Ð²ÑÐ¹ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ", blinkMove: CGFloat = 0, blinkMove2: CGFloat = 0.048, drawingImage: URL) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 164, height: 200), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 164, y: resizedFrame.height / 200)


        //// Color Declarations
        let gradientColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 0.000)
        let color5 = UIColor(red: 0.007, green: 0.000, blue: 0.440, alpha: 1.000)
        let gradient4Color = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.308)
        let gradient4Color2 = UIColor(red: 0.000, green: 0.021, blue: 1.000, alpha: 0.000)

        //// Gradient Declarations
        let gradient4 = CGGradient(colorsSpace: nil, colors: [gradient4Color2.cgColor, gradient4Color2.blended(withFraction: 0.5, of: gradient4Color).cgColor, gradient4Color.cgColor, gradient4Color.blended(withFraction: 0.5, of: gradientColor).cgColor, gradientColor.cgColor] as CFArray, locations: [0.48, 0.56, 0.57, 0.57, 0.57])!

        //// Image Declarations
        let myImage = UIImage(named: drawingImage.absoluteString)!

        //// Variable Declarations
        let blinkExpr: CGFloat = blinkMove == 0 || blinkMove == 1 ? 0 : (abs(cos((1 - blinkMove) * 1.25 * CGFloat.pi * 10 / CGFloat.pi * 180 * CGFloat.pi/180)) * 0.4 + 0.6) * 20
        let blinkOpacity: CGFloat = blinkMove == 0 && blinkMove == 1 ? 0 : 0.6
        let showDetailBlinkExp2: CGFloat = -220 * blinkMove2

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 0, y: 0, width: 164, height: 164))
        color5.setFill()
        ovalPath.fill()


        //// Picture Drawing
        context.saveGState()
        context.translateBy(x: 0, y: 11)
        context.scaleBy(x: 0.33, y: 0.33)

        let picturePath = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 485, height: 417))
        context.saveGState()
        picturePath.addClip()
        context.translateBy(x: 0, y: 0)
        context.scaleBy(x: 1, y: -1)
        context.translateBy(x: 0, y: -myImage.size.height)
        context.draw(myImage.cgImage!, in: CGRect(x: 0, y: 0, width: myImage.size.width, height: myImage.size.height))
        context.restoreGState()

        context.restoreGState()


        //// Effect Drawing
        context.saveGState()
        context.translateBy(x: 0, y: 11)
        context.scaleBy(x: 0.33, y: 0.33)

        context.saveGState()
        context.setAlpha(blinkOpacity)

        let effectRect = CGRect(x: blinkExpr, y: 0, width: 485, height: 417)
        let effectPath = UIBezierPath(rect: effectRect)
        context.saveGState()
        effectPath.addClip()
        context.translateBy(x: floor(effectRect.minX + 0.5), y: floor(effectRect.minY + 0.5))
        context.scaleBy(x: 1, y: -1)
        context.translateBy(x: 0, y: -myImage.size.height)
        context.draw(myImage.cgImage!, in: CGRect(x: 0, y: 0, width: myImage.size.width, height: myImage.size.height))
        context.restoreGState()

        context.restoreGState()

        context.restoreGState()


        //// Text Drawing
        let textRect = CGRect(x: 0, y: 150, width: 164, height: 50)
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont(name: "Play", size: 22.5)!,
            .foregroundColor: UIColor.white,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = userName.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        userName.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()


        //// BlinkGroup 2
        context.saveGState()
        context.beginTransparencyLayer(auxiliaryInfo: nil)


        //// Oval 4 Drawing
        let oval4Path = UIBezierPath(ovalIn: CGRect(x: 0, y: 0, width: 164, height: 164))
        UIColor.black.setFill()
        oval4Path.fill()


        //// Rectangle 2 Drawing
        context.saveGState()
        context.translateBy(x: 164, y: 0)

        context.saveGState()
        context.setBlendMode(.sourceIn)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        let rectangle2Rect = CGRect(x: (showDetailBlinkExp2 - 164), y: 0, width: 409.87, height: 164)
        let rectangle2Path = UIBezierPath(rect: rectangle2Rect)
        context.saveGState()
        rectangle2Path.addClip()
        context.drawLinearGradient(gradient4,
            start: CGPoint(x: rectangle2Rect.maxX, y: rectangle2Rect.midY),
            end: CGPoint(x: rectangle2Rect.minX, y: rectangle2Rect.midY),
            options: [])
        context.restoreGState()

        context.endTransparencyLayer()
        context.restoreGState()

        context.restoreGState()


        context.endTransparencyLayer()
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawBkg(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 414, height: 896), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 414, height: 896), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 414, y: resizedFrame.height / 896)



        //// Image Declarations
        let profileBkg = UIImage(named: "profileBkg.png")!

        //// Picture Drawing
        context.saveGState()
        context.translateBy(x: -86.44, y: -127.82)
        context.scaleBy(x: 0.33, y: 0.33)

        let picturePath = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 2025, height: 4034))
        context.saveGState()
        picturePath.addClip()
        context.translateBy(x: 0, y: 0)
        context.scaleBy(x: 1, y: -1)
        context.translateBy(x: 0, y: -profileBkg.size.height)
        context.draw(profileBkg.cgImage!, in: CGRect(x: 0, y: 0, width: profileBkg.size.width, height: profileBkg.size.height))
        context.restoreGState()

        context.restoreGState()
        
        context.restoreGState()

    }




    @objc(AvaKitResizingBehavior)
    public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}



private extension UIColor {
    func blended(withFraction fraction: CGFloat, of color: UIColor) -> UIColor {
        var r1: CGFloat = 1, g1: CGFloat = 1, b1: CGFloat = 1, a1: CGFloat = 1
        var r2: CGFloat = 1, g2: CGFloat = 1, b2: CGFloat = 1, a2: CGFloat = 1

        self.getRed(&r1, green: &g1, blue: &b1, alpha: &a1)
        color.getRed(&r2, green: &g2, blue: &b2, alpha: &a2)

        return UIColor(red: r1 * (1 - fraction) + r2 * fraction,
            green: g1 * (1 - fraction) + g2 * fraction,
            blue: b1 * (1 - fraction) + b2 * fraction,
            alpha: a1 * (1 - fraction) + a2 * fraction);
    }
}
