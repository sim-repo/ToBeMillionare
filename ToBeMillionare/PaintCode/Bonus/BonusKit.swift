//
//  BonusKit.swift
//  ProjectName
//
//  Created by Igor Ivanov on 23.08.2020.
//  Copyright © 2020 None. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class BonusKit : NSObject {

    //// Drawing Methods

    @objc dynamic public class func drawBonus(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 300, height: 60), resizing: ResizingBehavior = .aspectFit, move: CGFloat = 0.741, bonusText: String = "бонус: +$100") {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 300, height: 60), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 300, y: resizedFrame.height / 60)


        //// Color Declarations
        let color = UIColor(red: 0.352, green: 0.945, blue: 0.877, alpha: 1.000)
        let spot4Color2 = UIColor(red: 0.556, green: 0.000, blue: 1.000, alpha: 1.000)
        let base2LightGradientColor = UIColor(red: 0.451, green: 0.741, blue: 0.735, alpha: 1.000)
        let fillColor17 = UIColor(red: 0.000, green: 0.559, blue: 0.592, alpha: 1.000)
        let gradientColor2 = UIColor(red: 0.000, green: 0.422, blue: 1.000, alpha: 1.000)
        let color4 = UIColor(red: 0.014, green: 0.077, blue: 0.479, alpha: 1.000)

        //// Image Declarations
        let iena = UIImage(named: "iena.png")!

        //// Variable Declarations
        let phase1: CGFloat = move < 0.1 ? move * 300 * 10 + 40 * (0.1 - move) * 10 : (move >= 0.1 && move <= 0.8 ? 300 : (move > 0.8 && move <= 0.9 ? (0.9 - move) * 10 * 300 + 40 * (move - 0.8) * 10 : 40))
        let phase3: CGFloat = move <= 0.2 ? 0 : (move > 0.2 && move <= 0.3 ? (move - 0.2) * 10 : (move > 0.7 ? 0 : 1))
        let phase4: CGFloat = move <= 0.3 ? 0 : (move > 0.3 && move <= 0.4 ? (move - 0.3) * 10 : (move > 0.7 ? 0 : 1))
        let phase5: CGFloat = move <= 0.6 ? 0 : (move > 0.6 && move <= 0.7 ? (move - 0.6) * 10 : (move > 0.7 && move <= 0.9 ? 1 : (move > 0.9 ? (1 - move) * 10 : 0)))
        let phase6: CGFloat = move <= 0.7 ? 220 : (move > 0.7 && move <= 0.8 ? 220 * (0.8 - move) * 10 : 0)
        let sinus: CGFloat = abs(sin(move * 10 / CGFloat.pi * 180 * CGFloat.pi/180) + 0.09)
        let phase2_1: CGFloat = move <= 0.1 ? 0 : (move > 0.1 && move <= 0.2 ? 260 * (move - 0.1) * 10 : (move > 0.2 && move <= 0.7 ? 260 * sinus + 180 * (1 - sinus) : (move > 0.7 && move <= 0.8 ? 238 * (0.8 - move) * 10 : 0)))
        let phase2_2: CGFloat = move <= 0.1 ? 0 : (move > 0.1 && move <= 0.2 ? 180 * (move - 0.1) * 10 : (move > 0.2 && move <= 0.7 ? 180 * sinus + 260 * (1 - sinus) : (move > 0.7 && move <= 0.8 ? 202 * (0.8 - move) * 10 : 0)))
        let phase2_3: CGFloat = move > 0.2 && move <= 0.7 ? 70 * (1 - sinus) : 0
        let textMoveExp = move < 0.1 ? CGPoint(x: move * 290 * 10, y: 45) : (move >= 0.1 && move <= 0.2 ? CGPoint(x: 300, y: 45 * (0.2 - move) * 10 + 15 * (move - 0.1) * 10) : (move > 0.2 && move <= 0.7 ? CGPoint(x: 300, y: 15) : (move > 0.7 && move <= 0.8 ? CGPoint(x: 300, y: (0.8 - move) * 10 + 45 * (move - 0.7) * 10) : (move > 0.8 && move <= 0.9 ? CGPoint(x: (0.9 - move) * 300 * 10, y: 45) : CGPoint(x: 0, y: 45)))))
        let opacity: CGFloat = move == 0 || move == 1 ? 0 : 0.8

        //// Rectangle 3 Drawing
        context.saveGState()
        context.setAlpha(opacity)

        let rectangle3Path = UIBezierPath(roundedRect: CGRect(x: 0.98, y: 19.01, width: phase1, height: 40), cornerRadius: 20)
        color4.setFill()
        rectangle3Path.fill()

        context.restoreGState()


        //// Oval 7 Drawing
        context.saveGState()
        context.setAlpha(opacity)

        let oval7Path = UIBezierPath(ovalIn: CGRect(x: (phase2_2 + 0.978515625), y: 19.01, width: 40, height: 40))
        spot4Color2.setFill()
        oval7Path.fill()

        context.restoreGState()


        //// Oval1 Drawing
        context.saveGState()
        context.setAlpha(opacity)

        let oval1Path = UIBezierPath(ovalIn: CGRect(x: (phase2_1 + 0.978515625), y: 19.01, width: 40, height: 40))
        gradientColor2.setFill()
        oval1Path.fill()

        context.restoreGState()


        //// Group 2
        context.saveGState()
        context.setAlpha(phase3)
        context.beginTransparencyLayer(auxiliaryInfo: nil)


        //// Bezier 205 Drawing
        let bezier205Path = UIBezierPath()
        bezier205Path.move(to: CGPoint(x: 221.42, y: 35.88))
        bezier205Path.addLine(to: CGPoint(x: 231.47, y: 29.75))
        bezier205Path.addLine(to: CGPoint(x: 251.16, y: 41.06))
        bezier205Path.addLine(to: CGPoint(x: 240.92, y: 47.13))
        bezier205Path.addLine(to: CGPoint(x: 221.42, y: 35.88))
        bezier205Path.close()
        UIColor.black.setStroke()
        bezier205Path.lineWidth = 0.1
        bezier205Path.stroke()


        //// Bezier 206 Drawing
        let bezier206Path = UIBezierPath()
        bezier206Path.move(to: CGPoint(x: 241.01, y: 49.94))
        bezier206Path.addLine(to: CGPoint(x: 221.26, y: 38.72))
        bezier206Path.addLine(to: CGPoint(x: 221.26, y: 35.8))
        bezier206Path.addLine(to: CGPoint(x: 240.97, y: 47.1))
        bezier206Path.addLine(to: CGPoint(x: 241.01, y: 49.94))
        bezier206Path.close()
        UIColor.black.setStroke()
        bezier206Path.lineWidth = 0.1
        bezier206Path.stroke()


        //// Bezier 207 Drawing
        let bezier207Path = UIBezierPath()
        bezier207Path.move(to: CGPoint(x: 251.26, y: 41.03))
        bezier207Path.addLine(to: CGPoint(x: 251.34, y: 43.91))
        bezier207Path.addLine(to: CGPoint(x: 241.01, y: 49.94))
        bezier207Path.addLine(to: CGPoint(x: 240.9, y: 47.08))
        bezier207Path.addLine(to: CGPoint(x: 251.26, y: 41.03))
        bezier207Path.close()
        UIColor.black.setStroke()
        bezier207Path.lineWidth = 0.1
        bezier207Path.stroke()


        context.endTransparencyLayer()
        context.restoreGState()


        //// Group
        context.saveGState()
        context.setAlpha(phase4)
        context.beginTransparencyLayer(auxiliaryInfo: nil)


        //// Bezier 208 Drawing
        let bezier208Path = UIBezierPath()
        bezier208Path.move(to: CGPoint(x: 221.34, y: 35.91))
        bezier208Path.addLine(to: CGPoint(x: 231.39, y: 29.78))
        bezier208Path.addLine(to: CGPoint(x: 251.07, y: 41.09))
        bezier208Path.addLine(to: CGPoint(x: 240.84, y: 47.16))
        bezier208Path.addLine(to: CGPoint(x: 221.34, y: 35.91))
        bezier208Path.close()
        color.setFill()
        bezier208Path.fill()


        //// Bezier 209 Drawing
        let bezier209Path = UIBezierPath()
        bezier209Path.move(to: CGPoint(x: 240.92, y: 49.97))
        bezier209Path.addLine(to: CGPoint(x: 221.18, y: 38.74))
        bezier209Path.addLine(to: CGPoint(x: 221.17, y: 35.83))
        bezier209Path.addLine(to: CGPoint(x: 240.89, y: 47.13))
        bezier209Path.addLine(to: CGPoint(x: 240.92, y: 49.97))
        bezier209Path.close()
        base2LightGradientColor.setFill()
        bezier209Path.fill()


        //// Bezier 210 Drawing
        let bezier210Path = UIBezierPath()
        bezier210Path.move(to: CGPoint(x: 251.17, y: 41.06))
        bezier210Path.addLine(to: CGPoint(x: 251.25, y: 43.94))
        bezier210Path.addLine(to: CGPoint(x: 240.93, y: 49.97))
        bezier210Path.addLine(to: CGPoint(x: 240.81, y: 47.11))
        bezier210Path.addLine(to: CGPoint(x: 251.17, y: 41.06))
        bezier210Path.close()
        fillColor17.setFill()
        bezier210Path.fill()


        context.endTransparencyLayer()
        context.restoreGState()


        //// Group 5
        context.saveGState()
        context.beginTransparencyLayer(auxiliaryInfo: nil)


        //// Group 3
        context.saveGState()
        context.setAlpha(phase4)
        context.beginTransparencyLayer(auxiliaryInfo: nil)


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 221.34, y: 35.91))
        bezierPath.addLine(to: CGPoint(x: 231.39, y: 29.78))
        bezierPath.addLine(to: CGPoint(x: 251.07, y: 41.09))
        bezierPath.addLine(to: CGPoint(x: 240.84, y: 47.16))
        bezierPath.addLine(to: CGPoint(x: 221.34, y: 35.91))
        bezierPath.close()
        color.setFill()
        bezierPath.fill()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 240.92, y: 49.97))
        bezier2Path.addLine(to: CGPoint(x: 221.18, y: 38.74))
        bezier2Path.addLine(to: CGPoint(x: 221.17, y: 35.83))
        bezier2Path.addLine(to: CGPoint(x: 240.89, y: 47.13))
        bezier2Path.addLine(to: CGPoint(x: 240.92, y: 49.97))
        bezier2Path.close()
        base2LightGradientColor.setFill()
        bezier2Path.fill()


        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: 251.17, y: 41.06))
        bezier3Path.addLine(to: CGPoint(x: 251.25, y: 43.94))
        bezier3Path.addLine(to: CGPoint(x: 240.93, y: 49.97))
        bezier3Path.addLine(to: CGPoint(x: 240.81, y: 47.11))
        bezier3Path.addLine(to: CGPoint(x: 251.17, y: 41.06))
        bezier3Path.close()
        fillColor17.setFill()
        bezier3Path.fill()


        context.endTransparencyLayer()
        context.restoreGState()


        //// Rectangle 4 Drawing
        context.saveGState()
        context.translateBy(x: 189.98, y: 29.08)

        context.saveGState()
        context.setBlendMode(.sourceIn)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        let rectangle4Path = UIBezierPath(rect: CGRect(x: (phase2_3 + 7.08913380565), y: 0, width: 3.13, height: 19.05))
        UIColor.black.setFill()
        rectangle4Path.fill()

        context.endTransparencyLayer()
        context.restoreGState()

        context.restoreGState()


        context.endTransparencyLayer()
        context.restoreGState()


        //// ie Drawing
        context.saveGState()
        context.translateBy(x: (phase6 + 0.978515625), y: 29.93)
        context.rotate(by: -0.25 * CGFloat.pi/180)
        context.scaleBy(x: 0.15, y: 0.15)

        context.saveGState()
        context.setAlpha(phase5)

        let ieRect = CGRect(x: 0, y: 0, width: 201, height: 135)
        let iePath = UIBezierPath(rect: ieRect)
        context.saveGState()
        iePath.addClip()
        context.translateBy(x: floor(ieRect.minX + 0.5), y: floor(ieRect.minY + 0.5))
        context.scaleBy(x: 1, y: -1)
        context.translateBy(x: 0, y: -iena.size.height)
        context.draw(iena.cgImage!, in: CGRect(x: 0, y: 0, width: iena.size.width, height: iena.size.height))
        context.restoreGState()

        context.restoreGState()

        context.restoreGState()


        //// Text Drawing
        let textRect = CGRect(x: (textMoveExp.x - 98.609375), y: (textMoveExp.y - 15.763671875), width: 97.92, height: 18.15)
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .left
        let textFontAttributes = [
            .font: UIFont(name: "Play", size: 16)!,
            .foregroundColor: UIColor.white,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = bonusText.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        bonusText.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawBonusIcon(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 30, height: 30), resizing: ResizingBehavior = .aspectFit, miniStarMove: CGFloat = 0.409, miniStarBlink: CGFloat = 1) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 30, height: 30), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 30, y: resizedFrame.height / 30)


        //// Color Declarations
        let color2 = UIColor(red: 1.000, green: 0.999, blue: 0.434, alpha: 1.000)
        let gradientColor2 = UIColor(red: 0.000, green: 0.422, blue: 1.000, alpha: 1.000)
        let gradientColor3 = UIColor(red: 0.986, green: 1.000, blue: 0.619, alpha: 1.000)
        let color5 = UIColor(red: 0.749, green: 0.000, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let gradient = CGGradient(colorsSpace: nil, colors: [gradientColor2.cgColor, gradientColor2.blended(withFraction: 0.5, of: gradientColor3).cgColor, gradientColor3.cgColor] as CFArray, locations: [0, 0.5, 1])!

        //// Variable Declarations
        let miniStarRotateExpr: CGFloat = -1 * miniStarMove * 360
        let miniStarOpacityExpr: CGFloat = miniStarMove == 0 ? 0 : 1 - miniStarMove
        let miniStarScaleOval: CGFloat = miniStarMove == 0 ? 0 : (miniStarMove <= 0.5 ? 1 + miniStarMove * 60 : (miniStarMove > 0.5 ? (1 - miniStarMove) * 60 : 0))
        let miniStarExpr2 = CGPoint(x: 15 * (1 - miniStarMove) + 2 * miniStarMove, y: 15 * (1 - miniStarMove) + 2 * miniStarMove)
        let miniStarExpr3 = CGPoint(x: 15 * (1 - miniStarMove) + 27 * miniStarMove, y: 15 * (1 - miniStarMove) + 27 * miniStarMove)
        let miniStarExpr4 = CGPoint(x: 15 * (1 - miniStarMove) + 2 * miniStarMove, y: 15 * (1 - miniStarMove) + 27 * miniStarMove)
        let miniStarExpr5 = CGPoint(x: 15 * (1 - miniStarMove) + 27 * miniStarMove, y: 15 * (1 - miniStarMove) + 2 * miniStarMove)
        let miniStarScale: CGFloat = abs(sin((miniStarBlink - 0.15) * 10 / CGFloat.pi * 180 * CGFloat.pi/180))

        //// Oval Drawing
        context.saveGState()
        context.translateBy(x: 15, y: 15)
        context.scaleBy(x: miniStarScaleOval, y: miniStarScaleOval)

        let ovalPath = UIBezierPath(ovalIn: CGRect(x: -0.5, y: -0.5, width: 1, height: 1))
        color5.setFill()
        ovalPath.fill()

        context.restoreGState()


        //// Star 2 Drawing
        context.saveGState()
        context.translateBy(x: miniStarExpr2.x, y: miniStarExpr2.y)
        context.rotate(by: -miniStarRotateExpr * CGFloat.pi/180)

        context.saveGState()
        context.setAlpha(miniStarOpacityExpr)

        let star2Path = UIBezierPath()
        star2Path.move(to: CGPoint(x: 0, y: -4))
        star2Path.addLine(to: CGPoint(x: 1.18, y: -1.62))
        star2Path.addLine(to: CGPoint(x: 3.8, y: -1.24))
        star2Path.addLine(to: CGPoint(x: 1.91, y: 0.62))
        star2Path.addLine(to: CGPoint(x: 2.35, y: 3.24))
        star2Path.addLine(to: CGPoint(x: 0, y: 2))
        star2Path.addLine(to: CGPoint(x: -2.35, y: 3.24))
        star2Path.addLine(to: CGPoint(x: -1.91, y: 0.62))
        star2Path.addLine(to: CGPoint(x: -3.8, y: -1.24))
        star2Path.addLine(to: CGPoint(x: -1.18, y: -1.62))
        star2Path.close()
        color2.setFill()
        star2Path.fill()

        context.restoreGState()

        context.restoreGState()


        //// Star 3 Drawing
        context.saveGState()
        context.translateBy(x: miniStarExpr3.x, y: miniStarExpr3.y)
        context.rotate(by: -miniStarRotateExpr * CGFloat.pi/180)

        context.saveGState()
        context.setAlpha(miniStarOpacityExpr)

        let star3Path = UIBezierPath()
        star3Path.move(to: CGPoint(x: 0, y: -4))
        star3Path.addLine(to: CGPoint(x: 1.18, y: -1.62))
        star3Path.addLine(to: CGPoint(x: 3.8, y: -1.24))
        star3Path.addLine(to: CGPoint(x: 1.91, y: 0.62))
        star3Path.addLine(to: CGPoint(x: 2.35, y: 3.24))
        star3Path.addLine(to: CGPoint(x: 0, y: 2))
        star3Path.addLine(to: CGPoint(x: -2.35, y: 3.24))
        star3Path.addLine(to: CGPoint(x: -1.91, y: 0.62))
        star3Path.addLine(to: CGPoint(x: -3.8, y: -1.24))
        star3Path.addLine(to: CGPoint(x: -1.18, y: -1.62))
        star3Path.close()
        color2.setFill()
        star3Path.fill()

        context.restoreGState()

        context.restoreGState()


        //// Star 4 Drawing
        context.saveGState()
        context.translateBy(x: miniStarExpr4.x, y: miniStarExpr4.y)
        context.rotate(by: -(miniStarRotateExpr + 360) * CGFloat.pi/180)

        context.saveGState()
        context.setAlpha(miniStarOpacityExpr)

        let star4Path = UIBezierPath()
        star4Path.move(to: CGPoint(x: 0, y: -4))
        star4Path.addLine(to: CGPoint(x: 1.18, y: -1.62))
        star4Path.addLine(to: CGPoint(x: 3.8, y: -1.24))
        star4Path.addLine(to: CGPoint(x: 1.91, y: 0.62))
        star4Path.addLine(to: CGPoint(x: 2.35, y: 3.24))
        star4Path.addLine(to: CGPoint(x: 0, y: 2))
        star4Path.addLine(to: CGPoint(x: -2.35, y: 3.24))
        star4Path.addLine(to: CGPoint(x: -1.91, y: 0.62))
        star4Path.addLine(to: CGPoint(x: -3.8, y: -1.24))
        star4Path.addLine(to: CGPoint(x: -1.18, y: -1.62))
        star4Path.close()
        color2.setFill()
        star4Path.fill()

        context.restoreGState()

        context.restoreGState()


        //// Star 5 Drawing
        context.saveGState()
        context.translateBy(x: miniStarExpr5.x, y: miniStarExpr5.y)
        context.rotate(by: -miniStarRotateExpr * CGFloat.pi/180)

        context.saveGState()
        context.setAlpha(miniStarOpacityExpr)

        let star5Path = UIBezierPath()
        star5Path.move(to: CGPoint(x: 0, y: -4))
        star5Path.addLine(to: CGPoint(x: 1.18, y: -1.62))
        star5Path.addLine(to: CGPoint(x: 3.8, y: -1.24))
        star5Path.addLine(to: CGPoint(x: 1.91, y: 0.62))
        star5Path.addLine(to: CGPoint(x: 2.35, y: 3.24))
        star5Path.addLine(to: CGPoint(x: 0, y: 2))
        star5Path.addLine(to: CGPoint(x: -2.35, y: 3.24))
        star5Path.addLine(to: CGPoint(x: -1.91, y: 0.62))
        star5Path.addLine(to: CGPoint(x: -3.8, y: -1.24))
        star5Path.addLine(to: CGPoint(x: -1.18, y: -1.62))
        star5Path.close()
        color2.setFill()
        star5Path.fill()

        context.restoreGState()

        context.restoreGState()


        //// Star Drawing
        context.saveGState()
        context.translateBy(x: 15, y: 15)
        context.rotate(by: -miniStarRotateExpr * CGFloat.pi/180)
        context.scaleBy(x: miniStarScale, y: miniStarScale)

        context.saveGState()
        context.setAlpha(miniStarOpacityExpr)

        let starPath = UIBezierPath()
        starPath.move(to: CGPoint(x: -0.02, y: -15))
        starPath.addLine(to: CGPoint(x: 2, y: -2.77))
        starPath.addLine(to: CGPoint(x: 14.25, y: -4.63))
        starPath.addLine(to: CGPoint(x: 3.24, y: 1.06))
        starPath.addLine(to: CGPoint(x: 8.8, y: 12.14))
        starPath.addLine(to: CGPoint(x: -0.02, y: 3.43))
        starPath.addLine(to: CGPoint(x: -8.83, y: 12.14))
        starPath.addLine(to: CGPoint(x: -3.28, y: 1.06))
        starPath.addLine(to: CGPoint(x: -14.28, y: -4.63))
        starPath.addLine(to: CGPoint(x: -2.03, y: -2.77))
        starPath.close()
        context.saveGState()
        starPath.addClip()
        context.drawRadialGradient(gradient,
            startCenter: CGPoint(x: -0.13, y: -0.44), startRadius: 13.5,
            endCenter: CGPoint(x: 0.1, y: -0.3), endRadius: 4.5,
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()

        context.restoreGState()

        context.restoreGState()
        
        context.restoreGState()

    }




    @objc(BonusKitResizingBehavior)
    public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}



private extension UIColor {
    func blended(withFraction fraction: CGFloat, of color: UIColor) -> UIColor {
        var r1: CGFloat = 1, g1: CGFloat = 1, b1: CGFloat = 1, a1: CGFloat = 1
        var r2: CGFloat = 1, g2: CGFloat = 1, b2: CGFloat = 1, a2: CGFloat = 1

        self.getRed(&r1, green: &g1, blue: &b1, alpha: &a1)
        color.getRed(&r2, green: &g2, blue: &b2, alpha: &a2)

        return UIColor(red: r1 * (1 - fraction) + r2 * fraction,
            green: g1 * (1 - fraction) + g2 * fraction,
            blue: b1 * (1 - fraction) + b2 * fraction,
            alpha: a1 * (1 - fraction) + a2 * fraction);
    }
}
