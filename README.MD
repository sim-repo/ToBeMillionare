1. В качестве практического задания к урокам 1 и 2 вы будете создавать игру в стиле «Кто хочет стать миллионером». Не нужно использовать SpriteKit. Все экраны делайте в сториборде с обычными UI-компонентами (UIButton, UILabel и другими). Придумайте или нагуглите вопросы к игре (достаточно 5–10). Создайте структуру Question, содержащую сам вопрос, варианты ответа и правильный ответ.
(* Дополнительно: можете добавить в структуру поля, отображающие, что будет, если взять подсказку «Звонок другу» или «Помощь зала».* )
Добавьте в проект эти вопросы.

2. Создайте экраны главного меню и игры. На экране главного меню должны быть кнопки «Играть» и «Результаты».
3. При нажатии на кнопку «Играть» должен открываться экран, на котором юзеру предлагается ответить на вопрос, выбрав ответ из четырех вариантов. При правильном ответе должен появляться следующий вопрос, при неправильном игра заканчивается. Верстку экрана с игрой придумайте самостоятельно.
(* Дополнительно: можете добавить в игру возможность использовать подсказку — «Звонок другу», «Помощь зала», «Убрать два неправильных ответа».*)

4. Создайте синглтон Game и класс GameSession (не синглтон). У Game создайте опциональное свойство типа GameSession. Когда нажимается кнопка «Играть» и начинается игра, создавайте новый GameSession и передайте его синглтону Game. В GameSession храните всю информацию о ходе текущей игры: сколько вопросов было решено правильно, сколько их всего (дополнительно: какие доступные подсказки остались; сколько юзер выиграет денег, если закончит игру). Всю эту информацию GameSession должен получать через delegate от GameViewController — вью-контроллера, на котором происходит игра и нажимаются кнопки ответов.
5. Когда игра заканчивается, в синглтоне Game посчитайте результат — какой процент от общего числа вопросов получили правильные ответы. Сохраните этот результат в синглтоне (подсказка: нужно отдельное свойство, массив результатов игры) и обнулите у него свойство GameSession, так как игра была завершена.
5. Используя паттерн Memento, сохраняйте результаты на диск, как это было сделано на уроке.




Паттерны:
    Singleton
    Delegate
    Memento



class Game (Singleton): 

var gameMode: Enum[easy, medium, hard] 

var gameSession: GameSession? // ссылка на сессию
var questions: [Question]? // содержит вопросы
var stats: Stats? // хранится статистика игры

func setGameSession(gameSession: GameSession)
func didFinish() // запускается подсчет статистики, обнуляется gameSession, вызывается из GameSession, сохранить на диск

func calcStats() // вычисляет статистику
func saveStats() // сохраняет статистику на диск



class GameSessionModel

var level: Int = 0
var usedFriendHint: Bool = false // помощь друга
var usedAuditoryHint: Bool = false // помошь зала
var usedFiftyPercentHint: Bool = false // подсказка 50/50
var award: Int // сколько денег получит

func didFinish() // запускается подсчет статистики, обнуляется gameSession, вызывается из View


class GameSessionPresenter
    func useFriendHint()
    func useAuditoryHint
    func fiftyPercentHint()



class Stats

var player: String
var level: Int = 0
var date: Date



class Options

var mode: Enum[easy, medium, hard] // stategy




class PlayViewController

Label:  observer - номер текущего вопроса и сколько процентов от общего числа вопросов уже получили правильный ответ



class Menu

«Добавить вопрос».



class NewQuestion

(дополнительно: если делали подсказки в модели вопроса, то их поведение сгенерируйте случайным образом — то есть юзер не должен задавать эти поля)
savePersistent



class NewQuestionTableViewController

button "+" 
button "Добавить" - builder.build()






1. Ранее в вашей игре вопросы должны были идти последовательно, каждую новую игру в одном и том же порядке. Теперь сделайте два варианта —когда вопросы идут последовательно и когда перемешиваются в случайном порядке при каждой игре. Используйте паттерн strategy.
2. Добавьте экран настроек игры (для перехода в него в меню должна быть отдельная кнопка). В настройках сделайте возможность выбрать, в каком порядке идут вопросы — в случайном или последовательном. Выбранный вариант должен сохраниться в синглтоне Game и использоваться в самой игре.
3. Добавьте на экран игры лейбл, в котором будет указан номер текущего вопроса и сколько процентов от общего числа вопросов уже получили правильный ответ. С помощью observer (используйте обертку Observable<Type>; если сложно, воспользуйтесь NotificationCenter), следите за этими данными (в вашей архитектуре они должны быть в объекте GameSession) и отображайте на экране в лейбле.
4. Реализуйте в приложении возможность самому добавить новый вопрос. На экран меню поместите еще одну кнопку — «Добавить вопрос». При нажатии на нее открывается новый экран с формой ввода вопроса. Пользователь заполняет поля, нажимает «Добавить», и этот вопрос добавляется в игру в дополнение к уже существующим (дополнительно: если делали подсказки в модели вопроса, то их поведение сгенерируйте случайным образом — то есть юзер не должен задавать эти поля). Используя паттерн memento, добавьте еще один Caretaker для того, чтобы сохранять созданные юзером вопросы на диск и использовать их при последующих запусках приложения.
5. * Задание на паттерн Builder. Экран добавления вопроса реализуйте в виде вью-контроллера с table view. Форма заполнения вопроса — это ячейка UITableView с текстовыми полями. Внизу table view добавьте кнопку в виде плюса, при нажатии на которую к table view добавится еще одна ячейка с формой ввода вопроса. Кнопка «Добавить» должна добавлять в приложение не один вопрос, а массив вопросов. Создание массива новых вопросов из введенных на экране данных реализуйте с помощью builder. Билдер при вызове функции build() должен вернуть именно массив вопросов. Сам билдер можно хранить и использовать прямо во время работы программы — когда юзер что-то ввел, у билдера вызвали соответствующий метод.
6. ** Задание на паттерн Facade. Реализуйте возможность использовать подсказки «Звонок другу», «Помощь зала» и «50/50», если еще не сделали этого (в скобках с пометкой «дополнительно» в предыдущих заданиях были описаны шаги по созданию этой функциональности). В самой игре юзер при ответе на вопрос может нажать на одну из трех кнопок с подсказками. При этом нужно обратиться к модели текущего вопроса и вызвать у него одно из поведений при подсказке. Закройте доступ к этим подсказкам фасадом, применив паттерн facade. У GameSession добавьте свойство с фасадом HintUsageFacade. Этот фасад должен хранить свойство «текущий вопрос», и у него должны быть методы callFriend(), useAuditoryHelp(), use50to50Hint(). Подумайте, как лучше архитектурно реализовать использование этого фасада и как он будет передавать результат вызова метода наружу, во вью-контроллер. Это задание с двумя звездами — здесь вам нужно самостоятельно решить архитектурную задачу!




Паттерны:
    Strategy 
    Observer
    Builder
    Facade 


cairosvg play.svg -o play.pdf


Ошибка: 50x50
Выборка вопросов



City Skyscrapers Isometric Set
Smart home elements isometric icons collection
Astronautics equipment isometric illustration

Futuristic hud interface with gradient style
Isometric mars colonization

Mars colonization isometric composition
engineering isometric